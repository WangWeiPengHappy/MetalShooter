# MetalShooter 代码实现指导

## 开发优先级和实现顺序

基于设计文档，我们按照以下顺序来实现代码，确保每个阶段都有可测试的结果。

## 阶段一：核心基础架构 (第1-2周)

### 优先级 1: 数学库和基础类型

#### 1.1 数学基础 (`Engine/Math/`)

**MathTypes.swift** - 定义核心数学类型
```swift
import simd

typealias Float2 = simd_float2
typealias Float3 = simd_float3
typealias Float4 = simd_float4
typealias Float4x4 = simd_float4x4
typealias Quaternion = simd_quatf

struct Vertex {
    var position: Float3
    var normal: Float3
    var texCoords: Float2
    var color: Float4
}

struct Transform {
    var position: Float3 = Float3(0, 0, 0)
    var rotation: Quaternion = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1)
    var scale: Float3 = Float3(1, 1, 1)
    
    var matrix: Float4x4 {
        let translationMatrix = matrix_identity_float4x4.translated(by: position)
        let rotationMatrix = Float4x4(rotation)
        let scaleMatrix = matrix_identity_float4x4.scaled(by: scale)
        return translationMatrix * rotationMatrix * scaleMatrix
    }
}
```

**为什么先写这个？**
- 所有3D系统都依赖数学运算
- 后续的变换、物理、渲染都需要这些基础类型
- 可以立即测试和验证数学计算的正确性

#### 1.2 时间系统 (`Engine/Core/Time.swift`)

```swift
import Foundation

class Time {
    static let shared = Time()
    
    private var lastFrameTime: CFTimeInterval = 0
    private var _deltaTime: Float = 0
    private var _totalTime: Float = 0
    private var frameCount: Int = 0
    
    var deltaTime: Float { return _deltaTime }
    var totalTime: Float { return _totalTime }
    var fps: Float { return _deltaTime > 0 ? 1.0 / _deltaTime : 0 }
    
    func update() {
        let currentTime = CACurrentMediaTime()
        if lastFrameTime == 0 {
            lastFrameTime = currentTime
        }
        
        _deltaTime = Float(currentTime - lastFrameTime)
        _totalTime += _deltaTime
        lastFrameTime = currentTime
        frameCount += 1
    }
}
```

**为什么需要时间系统？**
- 游戏循环需要时间控制
- 物理模拟需要deltaTime
- 动画和插值都依赖时间

### 优先级 2: ECS 核心系统

#### 2.1 组件基类 (`ECS/Core/Component.swift`)

```swift
import Foundation

protocol Component: AnyObject {
    var entityId: UUID { get set }
}

// 标记协议用于类型安全
protocol ComponentType {
    static var typeId: String { get }
}

extension ComponentType {
    static var typeId: String {
        return String(describing: Self.self)
    }
}
```

#### 2.2 实体管理器 (`ECS/Core/EntityManager.swift`)

```swift
import Foundation

class EntityManager {
    static let shared = EntityManager()
    
    private var entities: Set<UUID> = []
    private var components: [String: [UUID: Component]] = [:]
    private var componentPools: [String: [Component]] = [:]
    
    func createEntity() -> UUID {
        let entityId = UUID()
        entities.insert(entityId)
        return entityId
    }
    
    func destroyEntity(_ entityId: UUID) {
        entities.remove(entityId)
        // 移除该实体的所有组件
        for (_, componentDict) in components {
            if let component = componentDict[entityId] {
                removeComponent(component, from: entityId)
            }
        }
    }
    
    func addComponent<T: Component & ComponentType>(_ component: T, to entityId: UUID) {
        guard entities.contains(entityId) else { return }
        
        component.entityId = entityId
        let typeId = T.typeId
        
        if components[typeId] == nil {
            components[typeId] = [:]
        }
        components[typeId]![entityId] = component
    }
    
    func getComponent<T: Component & ComponentType>(_ type: T.Type, for entityId: UUID) -> T? {
        let typeId = T.typeId
        return components[typeId]?[entityId] as? T
    }
    
    func getEntitiesWith<T: Component & ComponentType>(_ type: T.Type) -> [UUID] {
        let typeId = T.typeId
        return Array(components[typeId]?.keys ?? [])
    }
}
```

**为什么ECS要早实现？**
- ECS是整个游戏架构的核心
- 后续所有系统都基于ECS工作
- 可以先创建简单实体测试架构

### 优先级 3: 基础组件

#### 3.1 变换组件 (`ECS/Components/TransformComponent.swift`)

```swift
import simd

class TransformComponent: Component, ComponentType {
    var entityId: UUID = UUID()
    
    var transform: Transform
    var parent: UUID?
    var children: Set<UUID> = []
    
    init(position: Float3 = Float3(0, 0, 0), 
         rotation: Quaternion = simd_quatf(ix: 0, iy: 0, iz: 0, r: 1),
         scale: Float3 = Float3(1, 1, 1)) {
        self.transform = Transform()
        self.transform.position = position
        self.transform.rotation = rotation
        self.transform.scale = scale
    }
    
    var worldMatrix: Float4x4 {
        if let parentId = parent,
           let parentTransform = EntityManager.shared.getComponent(TransformComponent.self, for: parentId) {
            return parentTransform.worldMatrix * transform.matrix
        }
        return transform.matrix
    }
}
```

## 阶段二：Metal 渲染基础 (第2-3周)

### 优先级 4: Metal 设备和基础渲染

#### 4.1 Metal 设备管理 (`Rendering/Core/MetalDevice.swift`)

```swift
import Metal
import MetalKit

class MetalDevice {
    static let shared = MetalDevice()
    
    let device: MTLDevice
    let commandQueue: MTLCommandQueue
    
    private init() {
        guard let device = MTLCreateSystemDefaultDevice() else {
            fatalError("Metal is not supported on this device")
        }
        self.device = device
        
        guard let commandQueue = device.makeCommandQueue() else {
            fatalError("Could not create command queue")
        }
        self.commandQueue = commandQueue
        
        print("Metal Device: \(device.name)")
        print("Metal supports Apple Silicon optimizations: \(device.hasUnifiedMemory)")
    }
}
```

#### 4.2 着色器类型定义 (`Shaders/Common/ShaderTypes.h`)

```c
#ifndef ShaderTypes_h
#define ShaderTypes_h

#include <simd/simd.h>

typedef struct {
    simd_float3 position;
    simd_float3 normal;
    simd_float2 texCoords;
    simd_float4 color;
} Vertex;

typedef struct {
    simd_float4x4 modelMatrix;
    simd_float4x4 viewMatrix;
    simd_float4x4 projectionMatrix;
} Uniforms;

typedef struct {
    simd_float3 position;
    simd_float3 direction;
    simd_float3 color;
    float intensity;
} Light;

#endif
```

#### 4.3 基础顶点着色器 (`Shaders/Common/Vertex.metal`)

```metal
#include <metal_stdlib>
#include "ShaderTypes.h"
using namespace metal;

struct VertexOut {
    float4 position [[position]];
    float3 worldPosition;
    float3 normal;
    float2 texCoords;
    float4 color;
};

vertex VertexOut vertex_main(uint vertexID [[vertex_id]],
                            constant Vertex *vertices [[buffer(0)]],
                            constant Uniforms &uniforms [[buffer(1)]]) {
    VertexOut out;
    
    Vertex in = vertices[vertexID];
    
    float4 worldPosition = uniforms.modelMatrix * float4(in.position, 1.0);
    out.position = uniforms.projectionMatrix * uniforms.viewMatrix * worldPosition;
    out.worldPosition = worldPosition.xyz;
    out.normal = (uniforms.modelMatrix * float4(in.normal, 0.0)).xyz;
    out.texCoords = in.texCoords;
    out.color = in.color;
    
    return out;
}
```

#### 4.4 基础片段着色器 (`Shaders/Common/Fragment.metal`)

```metal
#include <metal_stdlib>
#include "ShaderTypes.h"
using namespace metal;

struct VertexOut {
    float4 position [[position]];
    float3 worldPosition;
    float3 normal;
    float2 texCoords;
    float4 color;
};

fragment float4 fragment_main(VertexOut in [[stage_in]],
                             constant Light &light [[buffer(0)]]) {
    float3 lightDirection = normalize(light.position - in.worldPosition);
    float diffuse = max(0.0, dot(normalize(in.normal), lightDirection));
    
    float3 finalColor = in.color.rgb * light.color * diffuse * light.intensity;
    
    return float4(finalColor, in.color.a);
}
```

## 阶段三：游戏循环和基础渲染 (第3-4周)

### 优先级 5: 游戏循环

#### 5.1 游戏引擎核心 (`Engine/Core/GameEngine.swift`)

```swift
import Foundation
import Metal
import MetalKit

class GameEngine {
    static let shared = GameEngine()
    
    private var isRunning = false
    private var systems: [GameSystem] = []
    private let entityManager = EntityManager.shared
    private var renderer: MetalRenderer!
    
    func initialize() {
        // 初始化渲染器
        renderer = MetalRenderer()
        renderer.initialize()
        
        // 注册系统
        registerSystems()
        
        // 初始化所有系统
        for system in systems {
            system.initialize()
        }
        
        print("GameEngine initialized")
    }
    
    private func registerSystems() {
        // 按执行顺序添加系统
        systems.append(PlayerSystem())
        systems.append(AISystem())
        systems.append(WeaponSystem())
        systems.append(PhysicsSystem())
        systems.append(RenderSystem(renderer: renderer))
    }
    
    func update() {
        Time.shared.update()
        
        // 更新所有系统
        for system in systems {
            system.update(deltaTime: Time.shared.deltaTime, entityManager: entityManager)
        }
    }
    
    func render() {
        renderer.render()
    }
    
    func start() {
        isRunning = true
        gameLoop()
    }
    
    func stop() {
        isRunning = false
    }
    
    private func gameLoop() {
        while isRunning {
            autoreleasepool {
                update()
                render()
            }
        }
    }
}
```

### 优先级 6: 基础系统接口

#### 6.1 游戏系统基类 (`ECS/Systems/GameSystem.swift`)

```swift
protocol GameSystem: AnyObject {
    func initialize()
    func update(deltaTime: Float, entityManager: EntityManager)
    func cleanup()
}
```

#### 6.2 渲染系统 (`ECS/Systems/RenderSystem.swift`)

```swift
class RenderSystem: GameSystem {
    private let renderer: MetalRenderer
    private var renderableEntities: [UUID] = []
    
    init(renderer: MetalRenderer) {
        self.renderer = renderer
    }
    
    func initialize() {
        print("RenderSystem initialized")
    }
    
    func update(deltaTime: Float, entityManager: EntityManager) {
        // 收集所有可渲染的实体
        renderableEntities = entityManager.getEntitiesWith(RenderComponent.self)
        
        // 准备渲染数据
        var renderData: [RenderData] = []
        
        for entityId in renderableEntities {
            guard let renderComponent = entityManager.getComponent(RenderComponent.self, for: entityId),
                  let transformComponent = entityManager.getComponent(TransformComponent.self, for: entityId) else {
                continue
            }
            
            if renderComponent.visible {
                let data = RenderData(
                    mesh: renderComponent.mesh,
                    material: renderComponent.material,
                    modelMatrix: transformComponent.worldMatrix
                )
                renderData.append(data)
            }
        }
        
        // 提交渲染数据
        renderer.submitRenderData(renderData)
    }
    
    func cleanup() {
        renderableEntities.removeAll()
    }
}
```

## 开发策略和最佳实践

### 1. **迭代式开发**
每个阶段都要有可运行的结果：
- 阶段一：能创建实体和组件
- 阶段二：能在屏幕上显示一个三角形
- 阶段三：能显示一个旋转的立方体
- 阶段四：能用键盘控制相机移动

### 2. **测试驱动**
为每个核心系统编写单元测试：
```swift
// MetalShooterTests/Core/EntityManagerTests.swift
import XCTest
@testable import MetalShooter

class EntityManagerTests: XCTestCase {
    func testCreateEntity() {
        let manager = EntityManager()
        let entity = manager.createEntity()
        XCTAssertNotNil(entity)
    }
    
    func testAddComponent() {
        let manager = EntityManager()
        let entity = manager.createEntity()
        let transform = TransformComponent()
        
        manager.addComponent(transform, to: entity)
        let retrieved = manager.getComponent(TransformComponent.self, for: entity)
        
        XCTAssertNotNil(retrieved)
        XCTAssertEqual(retrieved?.entityId, entity)
    }
}
```

### 3. **调试和性能监控**
从一开始就集成调试工具：
```swift
// Utilities/Debug/Logger.swift
import Foundation

enum LogLevel {
    case debug, info, warning, error
}

class Logger {
    static func log(_ message: String, level: LogLevel = .info, file: String = #file, line: Int = #line) {
        let filename = URL(fileURLWithPath: file).lastPathComponent
        let timestamp = DateFormatter().string(from: Date())
        print("[\(timestamp)] [\(level)] [\(filename):\(line)] \(message)")
    }
}
```

### 4. **渐进式复杂化**
不要一开始就实现所有功能：
- 先实现静态渲染 → 再加入动画
- 先实现键盘输入 → 再加入鼠标控制
- 先实现基础物理 → 再加入复杂碰撞

### 5. **文档化代码**
每个主要类都要有清晰的注释：
```swift
/// 管理游戏中所有实体和组件的核心系统
/// 使用 ECS 架构模式，支持高效的组件查询和实体管理
class EntityManager {
    /// 创建一个新的游戏实体
    /// - Returns: 新实体的唯一标识符
    func createEntity() -> UUID {
        // 实现...
    }
}
```

## 下一步行动计划

**今天开始**：
1. 实现 `MathTypes.swift` 和 `Time.swift`
2. 实现基础的 `Component` 协议和 `EntityManager`
3. 创建第一个 `TransformComponent`
4. 编写简单的测试验证功能

**明天继续**：
1. 实现 `MetalDevice` 和基础着色器
2. 创建简单的三角形渲染
3. 集成游戏循环

**本周目标**：
在屏幕上显示一个可以旋转的彩色立方体，并能用键盘控制相机移动。

你想从哪个模块开始实现？我建议先从数学库开始，因为它是所有其他系统的基础。
